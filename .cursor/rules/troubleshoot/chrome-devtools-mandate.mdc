---
description: Force Chrome DevTools tools for frontend debugging during /troubleshoot
globs: ".cursor/commands/troubleshoot/**,.cursor/troubleshoot/**"
alwaysApply: false
---

# Chrome DevTools Mandate (Non-Negotiable)

## Purpose

Chrome DevTools (`user-chrome-devtools` MCP) provides access to browser debugging capabilities:
- **Network requests** — API calls, headers, responses, timing
- **Console messages** — JS errors, warnings, logs
- **Performance traces** — CPU, rendering, scripting metrics
- **DOM snapshots** — Element structure, accessibility tree
- **Script evaluation** — Inspect JS state, variables

## MCP Selection (CRITICAL)

| MCP Server | Tools | Filtering |
|------------|-------|-----------|
| `user-chrome-devtools` | `list_network_requests`, `get_network_request` | Full params (resourceTypes, pageSize) |
| `user-MCP-S` | `chrome-devtools__list-network-requests` | NO params (limited) |

**Always use `user-chrome-devtools` for network inspection.**

---

## Available Tools

### 1) List Network Requests

```
server: user-chrome-devtools
toolName: list_network_requests
arguments:
  resourceTypes: ["fetch", "xhr"]  # Filter to API calls
  pageSize: 50                     # Limit results
  pageIdx: 0                       # Pagination (0-based)
  includePreservedRequests: true   # Include from nav history
```

**Returns:** List with reqid, url, method, status, resourceType

**Use when:** Finding failed requests, slow requests, CORS issues

---

### 2) Get Network Request Details

```
server: user-chrome-devtools
toolName: get_network_request
arguments:
  reqid: <number>  # From list_network_requests results
```

**Returns:** Full request/response with ALL headers (including `x-wix-request-id`)

**Use when:** Extracting request IDs for Grafana tracing, inspecting payloads

---

### 3) List Console Messages

```
server: user-chrome-devtools
toolName: list_console_messages
arguments: {}
```

**Returns:** JS errors, warnings, logs with timestamps

**Use when:** Finding JS errors, failed assertions, debug logs

---

### 4) Take Screenshot

```
server: user-chrome-devtools
toolName: take_screenshot
arguments: {}
```

**Returns:** Base64 encoded screenshot

**Use when:** Capturing visual state at failure point

---

### 5) Take DOM Snapshot

```
server: user-chrome-devtools
toolName: take_snapshot
arguments: {}
```

**Returns:** DOM tree structure

**Use when:** Inspecting element state, accessibility issues

---

### 6) Evaluate Script

```
server: user-chrome-devtools
toolName: evaluate_script
arguments:
  expression: "window.__DEBUG_STATE__"
```

**Returns:** JS evaluation result

**Use when:** Inspecting variables, state, calling debug functions

---

### 7) Performance Trace

```
# Start tracing
server: user-chrome-devtools
toolName: performance_start_trace
arguments: {}

# ... reproduce the slow action ...

# Stop and get results
server: user-chrome-devtools
toolName: performance_stop_trace
arguments: {}

# Get insights
server: user-chrome-devtools
toolName: performance_analyze_insight
arguments: {}
```

**Use when:** Diagnosing slow renders, CPU spikes, layout thrashing

---

## Request ID Tracing (x-wix-request-id → AI Root Cause Analysis)

When a network call fails or behaves unexpectedly, extract the `x-wix-request-id` header and use AI-powered root cause analysis.

### Step-by-Step Workflow

**Step 1: Find the Failed Request**

```
server: user-chrome-devtools
toolName: list_network_requests
arguments:
  resourceTypes: ["fetch", "xhr"]
  pageSize: 50
```

Look for requests with error status (4xx, 5xx) or suspicious responses.

**Step 2: Get Full Request Details**

```
server: user-chrome-devtools
toolName: get_network_request
arguments:
  reqid: <number>  # From step 1
```

Extract `x-wix-request-id` from RESPONSE headers (not request headers).

**Step 3: Start AI Root Cause Analysis (PRIMARY — MANDATORY)**

```
server: user-MCP-S-root-cause
toolName: start_root_cause_analysis
arguments:
  requestId: "<x-wix-request-id>"           # REQUIRED
  artifactIds: ["<service-name>"]           # OPTIONAL: filter to services
  hint: "<context about the issue>"         # OPTIONAL: guide analysis
```

Returns `analysisId` and `pollingUrl` immediately. Analysis runs async (4-5 min typical).

**Step 4: Poll for Results**

```
server: user-MCP-S-root-cause
toolName: await_root_cause_analysis
arguments:
  analysisId: "<from step 3>"
  timeoutSeconds: 25                        # Repeat if RUNNING
```

Status responses:
- `RUNNING`: Analysis in progress — call again with same analysisId
- `COMPLETED`: Contains markdown report with findings + `analysisUrl` for sharing
- `FAILED`: Contains reason — proceed to fallback

**Step 5 (FALLBACK ONLY): Query Grafana Logs**

Use ONLY when RCA returns non-informative results:

```
server: user-MCP-S
toolName: grafana-mcp__list_datasources
arguments:
  type: "loki"
```

Then query logs:

```
server: user-MCP-S
toolName: grafana-mcp__query_loki_logs
arguments:
  datasourceUid: "<uid>"
  logql: '{app=~".+"} |= "{REQUEST_ID}"'
  limit: 100
  direction: "backward"
```

**Grafana Dashboard URL (FALLBACK):**
```
https://grafana.wixpress.com/d/38cCoLymz/error-analytics-traceid
  ?orgId=1
  &var-request_id={REQUEST_ID}
```

### What AI Root Cause Analysis Reveals

- Automated root cause identification
- Correlated logs across all services in the request chain
- Error patterns and anomaly detection
- Suggested fixes based on similar past issues
- Full trace analysis in markdown format

### What x-wix-request-id + Grafana Fallback Reveals

- Full request trace across all backend services
- Error stack traces and context
- Service-to-service call chain
- Timing breakdown per service hop
- Which service threw the error

### Use Cases

- API returns unexpected error/status code
- Request succeeds but response data is wrong
- Need to trace request flow across microservices
- Investigating latency spikes
- Debugging intermittent failures
- Correlating frontend network error with backend logs

### CRITICAL: Tool Selection Rule

```
ALWAYS: start_root_cause_analysis FIRST
        ↓
     COMPLETED with findings? → USE IT
        ↓
     FAILED or non-informative? → FALLBACK to Grafana logs
        ↓
     MUST LOG: Why fallback was needed in mcp-s-notes.md
```

---

## Tool Selection by Task

| Task | Tool | Priority |
|------|------|----------|
| JS errors | `list_console_messages` | P0 |
| Failed API calls | `list_network_requests` | P0 |
| Request headers/body | `get_network_request` | P0 |
| Visual bugs | `take_screenshot` | P0 |
| DOM state | `take_snapshot` | P1 |
| JS state inspection | `evaluate_script` | P1 |
| Performance issues | `performance_*` | P0 (when perf) |

---

## Logging Requirement

All Chrome DevTools queries must be recorded in:
`.cursor/troubleshoot/<topic>/mcp-s-notes.md`

Format:
```markdown
## [Evidence/Topic]
- **Tool**: <tool name> (Chrome DevTools)
- **Phase**: Evidence
- **Arguments**: <exact args>
- **Findings**: <key insights>
- **Request IDs**: <x-wix-request-id if found>
- **Follow-up**: <next tool or code to investigate>
```

---

## Fallback Rule

If Chrome DevTools is unavailable (tools return errors, not connected):
- Use BrowserMCP as FALLBACK
- Log: "Chrome DevTools unavailable, used BrowserMCP fallback"
- Note: Network requests and performance NOT available in BrowserMCP
