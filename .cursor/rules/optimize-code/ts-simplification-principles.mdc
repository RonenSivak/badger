---
description: Core principles and refactoring techniques for TypeScript and React simplification
globs: "**/*.ts, **/*.tsx"
alwaysApply: false
---

# TypeScript & React Simplification Principles

## 12 Core TypeScript Principles

### 1. Single Responsibility
Functions do one thing. If a name uses "and" or function has multiple concerns, split it.

```typescript
// BAD
function validateAndSave(user: User) { ... }

// GOOD
function validate(user: User): ValidationResult { ... }
function save(user: User): void { ... }
```

### 2. Clear Naming
Descriptive, unambiguous names. Avoid `data`, `obj`, `handle`, acronyms.

```typescript
// BAD
const d = getData();
function handleClick() { ... }

// GOOD
const userProfile = fetchUserProfile();
function submitRegistrationForm() { ... }
```

### 3. Immutability
Prefer pure functions. Return new values instead of mutating.

```typescript
// BAD
items.push(newItem);

// GOOD
const updatedItems = [...items, newItem];
```

### 4. Reduce Nesting (Guard Clauses)
Use early returns to flatten code.

```typescript
// BAD
function process(order: Order) {
  if (order) {
    if (order.items.length) {
      // deep logic
    }
  }
}

// GOOD
function process(order: Order) {
  if (!order) return;
  if (!order.items.length) return;
  // flat logic
}
```

### 5. No Flag Parameters
Split functions instead of boolean switches.

```typescript
// BAD
function createFile(name: string, temp: boolean) { ... }

// GOOD
function createFile(name: string) { ... }
function createTempFile(name: string) { ... }
```

### 6. Leverage Types
Use discriminated unions, exhaustive checks, branded types.

```typescript
// Discriminated union
type Result<T> = 
  | { ok: true; value: T }
  | { ok: false; error: Error };

// Exhaustive check
function assertNever(x: never): never {
  throw new Error(`Unexpected: ${x}`);
}
```

### 7. Use Built-in Methods
Prefer `.map`, `.filter`, `.reduce` over manual loops.

```typescript
// BAD
const names = [];
for (const p of people) {
  names.push(p.name);
}

// GOOD
const names = people.map(p => p.name);
```

### 8. DRY Carefully
Abstract only when pattern repeats 3+ times and abstraction is clean.

### 9. Composition Over Inheritance
Prefer small functions/objects over class hierarchies.

### 10. Separation of Concerns
Keep UI, data, and logic separate. Pure core, imperative shell.

### 11. Strategic Error Handling
Fail fast with guard clauses. Consider Result types for expected errors.

```typescript
// Result type pattern
function parseJson<T>(str: string): Result<T> {
  try {
    return { ok: true, value: JSON.parse(str) };
  } catch (e) {
    return { ok: false, error: e as Error };
  }
}
```

### 12. Simple Tests
One concept per test. Use table-driven tests for multiple cases.

## Quick Refactor Patterns

### Extract Function
```typescript
// Before: inline logic
const total = items.reduce((sum, i) => sum + i.price * i.qty, 0);

// After: named function
const total = calculateTotal(items);
function calculateTotal(items: Item[]): number {
  return items.reduce((sum, i) => sum + i.price * i.qty, 0);
}
```

### Replace Conditional with Lookup
```typescript
// Before
if (type === 'a') return handleA();
else if (type === 'b') return handleB();

// After
const handlers = { a: handleA, b: handleB };
return handlers[type]();
```

### Simplify Boolean Logic
```typescript
// Before
if (!(user && !user.banned)) { return; }

// After
const canAccess = user && !user.banned;
if (!canAccess) return;
```

---

## 10 React-Specific Principles

### 1. Single-Responsibility Components
Components do one thing. Split data fetching from UI rendering.

```tsx
// BAD: Component handling UI + data + state
function UserFormPage() {
  const [formData, setFormData] = useState({});
  const [saved, setSaved] = useState(false);
  const handleSubmit = async () => { await api.saveUser(formData); };
  return <Form onSubmit={handleSubmit}>...</Form>;
}

// GOOD: Split into hook + component
function useSaveUser() {
  const [saved, setSaved] = useState(false);
  const saveUser = async (data) => { await api.saveUser(data); setSaved(true); };
  return { saveUser, saved };
}

function UserFormPage() {
  const { saveUser, saved } = useSaveUser();
  return <Form onSubmit={saveUser}>...</Form>;
}
```

### 2. State Colocation
Keep state as local as possible. Only lift to context/store when truly needed.

```tsx
// BAD: Global store for local UI state
const modalOpen = useSelector(state => state.ui.modalOpen);

// GOOD: Local state for local concerns
function SettingsModal() {
  const [isOpen, setOpen] = useState(false);
  return <>{isOpen && <Modal onClose={() => setOpen(false)} />}</>;
}
```

### 3. Limit Prop Drilling
Use composition or Context when passing props through many levels.

```tsx
// BAD: Drilling through 3+ levels
<Page currentUser={user}>
  <Toolbar currentUser={user}>
    <UserMenu currentUser={user} />
  </Toolbar>
</Page>

// GOOD: Context for deep access
<CurrentUserProvider value={user}>
  <Page><Toolbar><UserMenu /></Toolbar></Page>
</CurrentUserProvider>
```

### 4. Composition Over Conditionals
Split variants into separate components instead of boolean flags.

```tsx
// BAD: Conditional rendering in one component
function Notification({ type, message }) {
  if (type === 'error') return <div className="error">{message}</div>;
  if (type === 'warning') return <div className="warning">{message}</div>;
  return <div className="info">{message}</div>;
}

// GOOD: Separate components for variants
function ErrorAlert({ message }) { return <div className="error">{message}</div>; }
function WarningAlert({ message }) { return <div className="warning">{message}</div>; }
```

### 5. Custom Hooks for Reusable Logic
Extract shared logic (data fetching, subscriptions) into hooks.

```tsx
// Extract common fetch pattern
function useData<T>(url: string) {
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<Error | null>(null);
  useEffect(() => { fetch(url).then(r => r.json()).then(setData).catch(setError); }, [url]);
  return { data, error };
}

// Usage
const { data: users } = useData<User[]>('/api/users');
```

### 6. Minimal Props Interface
Keep component interfaces lean. Use discriminated unions for variants.

```tsx
// BAD: Many optional props
interface DataTableProps {
  data?: any[]; isRemote?: boolean; fetchUrl?: string;
  showFooter?: boolean; footerText?: string;
}

// GOOD: Discriminated union
type DataTableProps = 
  | { data: Item[] }  // local data
  | { fetchUrl: string };  // remote data

function DataTable(props: DataTableProps) {
  if ('fetchUrl' in props) { /* remote */ }
  else { /* local */ }
}
```

### 7. Leverage TypeScript for Safety
Use inference internally, explicit types at boundaries. Avoid `any`.

```tsx
// Let TS infer locals
const name = "Alice";  // string inferred
const scores = [10, 15];  // number[] inferred

// Explicit at boundaries
interface UserProps { user: User; }
function UserCard({ user }: UserProps) { return <div>{user.name}</div>; }
```

### 8. YAGNI and KISS
Start simple. Don't add abstractions until needed.

- Use `useState` before Redux
- Use `fetch` before React Query
- Build for current needs, not hypothetical future

### 9. Readability Over Cleverness
Prefer explicit, clear code over terse one-liners.

```tsx
// BAD: Clever but hard to read
return [condition && <Special />, ...items.map(i => <Item key={i.id} />)];

// GOOD: Explicit JSX
return (
  <>
    {condition && <Special />}
    {items.map(i => <Item key={i.id} data={i} />)}
  </>
);
```

### 10. Design for Testing
Use Error Boundaries, separate pure logic from side effects.

```tsx
// Wrap sections that might fail
<ErrorBoundary fallback={<ErrorFallback />}>
  <UserProfile />
</ErrorBoundary>
```

---

## React Refactor Patterns

### Extract Smaller Components
Break large components into focused pieces.

### Flatten Conditional Rendering
Move complex conditions above JSX return.

```tsx
const showAdvanced = user.isAdmin && mode === 'advanced';
return <>{showAdvanced && <AdvancedOptions />}</>;
```

### Use useReducer for Complex State
Centralize related state transitions.

```tsx
const [state, dispatch] = useReducer(formReducer, initialState);
// dispatch({ type: 'CHANGE', field: 'email', value: 'x@y.com' });
```

### Encapsulate Side Effects in Hooks
```tsx
function useInterval(callback: () => void, delay: number) {
  useEffect(() => {
    const id = setInterval(callback, delay);
    return () => clearInterval(id);
  }, [callback, delay]);
}
```

### Provider Pattern for Shared State
```tsx
const AuthContext = createContext<AuthValue | undefined>(undefined);

export function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error("useAuth must be inside AuthProvider");
  return ctx;
}
```

### Use React Query / SWR for Server State
```tsx
// Replace manual fetch + useState + useEffect
const { data, error, isLoading } = useQuery(['user', userId], () => api.fetchUser(userId));
```

### Feature-Based Project Structure
```
src/features/
  ShoppingCart/
    CartPage.tsx
    CartItem.tsx
    useCart.ts
    cartSlice.ts
```
